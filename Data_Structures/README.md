# 그림
![](./img/search.png)

## 요구사항
```{r, engine='bash', count_lines}
 >Here is the list for search : 0 1 2 3 4 5 6 7 8 9
found the number : 7

```
search함수를 이용하여 배열에서 7이라는 숫자를 출력하려고 합니다.
첫번째 그림처럼 num_List라는 배열을 주고 찾고자 하는 값을 7로 했을떄
인자로 준 배열을 출력하고, 찾은 값을 출력하도록 하면 됩니다 

## 구현방법
Search는 특정목록에서 특정값을 검색하는 작업을 하는 프로그램으로 검색될 요소의 위치를 알려주어야 합니다.이때 찾고자 하는 것을 명확히 정의 해주어야 합니다.
검색을 할때는 목록의 시작부터 목록의 끝까지 순차적으로 검색해 나가게 됩니다.

# 코드
[searching](./workbooksearch.c)

# 코드설명
search라는 함수는 인자로 찾을 값과 배열 그리고 그 배열의 크기를 갖게 됩니다.
변수 i의 역할은 for문의 인덱스 값의 역할을 하게되고, 
인자 값(찾을값)과 배열의 위치가 같아 질때까지 증가 하다가 값이 같아지면
변수 index에 i의 값을 할당시켜 주고 index 값을 반환한다 


# 그림![](./img/quicksort.png)

## 요구사항
```{r, engine='bash', count_lines}
>856941972
245678919
```

quickSort알고리즘을 이용하여 list배열을 순차적으로 정렬하고자합니다
그림 첫번째의 list배열을 주고 pivot값을 배열[0] 값으로 하였을때
결과값으로 순차적으로 정렬되어있는 배열이 출력 되게 하면 됩니다 

## 구현방법
qicksort알고리즘은 pivot를 기준으로 왼쪽에는 pivot보다 작은 수를, 오른쪽에는 pivot보다 큰수를 나열하게 되고 더 이상 배열이 나누어 질수 없을때까지 자기자신을 반복하게 됩니다.

# 코드
[quicksort](./quicksort.c)

# 코드설명
quicksort함수는 배열, 배열의 최대값, 최소값을 인자로 갖게 되고 pivot값을 할당하게 됩니다
그리고 partition함수를 이용해서 정렬을 하게 됩니다
partition함수는 인덱스i,j를 이용합니다 i는 배열의 맨앞쪽부터 1씩 증가해나가면서 pivot과 비교를 하다가 pivot 보다 큰수가 있으면 while문을 종료하게 되고 배열j번째는 배열의 맨끝부터 1씩감소해나가면서  pivot가 비교하게 됩니다 이때 배열j번째가 pivot 보다 작으면 배열i와 j의 값을 바꿔주게 됩니다
정열이끝나면 pivot을 두파트 사이에 자리 하게 되고, 각 파트들도 더이상 나누어 질수 없을때까지 반복정렬 해나가게 됩니다



